<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Golang反射reflect解析 | Chc</title><meta name="description" content="Golang反射reflect解析"><meta name="keywords" content="源码"><meta name="author" content="Chc"><meta name="copyright" content="Chc"><meta name="format-detection" content="telephone=no"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://blog.caihc.site/posts/2f2b16bc/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Golang反射reflect解析"><meta name="twitter:description" content="Golang反射reflect解析"><meta name="twitter:image" content="http://qiniu.caihc.site/go/reflectgolang%E5%8F%8D%E5%B0%84.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="Golang反射reflect解析"><meta property="og:url" content="https://blog.caihc.site/posts/2f2b16bc/"><meta property="og:site_name" content="Chc"><meta property="og:description" content="Golang反射reflect解析"><meta property="og:image" content="http://qiniu.caihc.site/go/reflectgolang%E5%8F%8D%E5%B0%84.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="Mysql基本运维知识总结" href="https://blog.caihc.site/posts/b60c2e78/"><link rel="next" title="MongoDB4.0配置说明" href="https://blog.caihc.site/posts/39601882/"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#反射基本函数"><span class="toc-number">1.</span> <span class="toc-text">反射基本函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeOf"><span class="toc-number">1.1.</span> <span class="toc-text">TypeOf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ValueOf"><span class="toc-number">1.2.</span> <span class="toc-text">ValueOf</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Type"><span class="toc-number">2.</span> <span class="toc-text">Type</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#value"><span class="toc-number">3.</span> <span class="toc-text">value</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StructField"><span class="toc-number">4.</span> <span class="toc-text">StructField</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反射的三大定律"><span class="toc-number">5.</span> <span class="toc-text">反射的三大定律</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://qiniu.caihc.site/go/reflectgolang%E5%8F%8D%E5%B0%84.jpeg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Chc</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Golang反射reflect解析</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-07-19<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-07-19</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/golang/">golang</a></span></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="反射基本函数"><a href="#反射基本函数" class="headerlink" title="反射基本函数"></a>反射基本函数</h1><p> <code>reflect.Type</code> 主要提供关于类型相关的信息，所以它和 _type 关联比较紧密；</p>
<p> <code>reflect.Value</code> 则结合 <code>_type</code>和 <code>data</code>两者，因此可以获取甚至改变类型的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span> // 返回<span class="title">i</span>的对象类型</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span> // 返回<span class="title">i</span>的<span class="title">Value</span><span class="params">(如果要对i进行修改的话传入变量地址)</span>    </span></span><br><span class="line"><span class="function"><span class="title">reflect</span>.<span class="title">Indirect</span><span class="params">(v value)</span> // 返回<span class="title">v</span>获取了该指针指向的值</span></span><br><span class="line"><span class="function"><span class="title">reflect</span>.<span class="title">New</span><span class="params">(typ Type)</span> // 返回一个新的<span class="title">type</span>类型的对象。</span></span><br></pre></td></tr></table></figure>

<h2 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line">  <span class="comment">// 将i转成emptyInterface</span></span><br><span class="line">	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">  <span class="comment">// emptyInterface的*rtype实现了Type的接口</span></span><br><span class="line">	<span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// *rtype实现了Type的接口</span></span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.caihc.site/go/reflectgo-reflect-01.PNG" alt></p>
<ul>
<li>将先将 <code>i</code> 转换成 <code>*emptyInterface</code> 类型,然後在返回<code>typ</code>字段,<code>rtype</code>实现了<code>Type</code>接口</li>
</ul>
<h2 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	escapes(i)</span><br><span class="line">	<span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆解rtype</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">  <span class="comment">// 将i转成emptyInterface</span></span><br><span class="line">	e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	t := e.typ</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f := flag(t.Kind())</span><br><span class="line">	<span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">		f |= flagIndir</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将先将 <code>i</code> 转换成 <code>*emptyInterface</code> 类型， 再将它的 <code>typ</code>字段和 <code>word</code> 字段以及一个标志位字段组装成一个 <code>Value</code> 结构体，而这就是 <code>ValueOf</code>函数的返回值，它包含类型结构体指针、真实数据的地址、标志位。</li>
</ul>
<h1 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 所有的类型都可以调用下面这些函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此类型的变量对齐后所占用的字节数</span></span><br><span class="line">	Align() <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 如果是 struct 的字段，对齐后占用的字节数</span></span><br><span class="line">	FieldAlign() <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 返回类型方法集里的第 `i` (传入的参数)个方法</span></span><br><span class="line">	Method(<span class="keyword">int</span>) Method</span><br><span class="line">    <span class="comment">// 通过名称获取方法</span></span><br><span class="line">	MethodByName(<span class="keyword">string</span>) (Method, <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// 获取类型方法集里导出的方法个数</span></span><br><span class="line">	NumMethod() <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 类型名称</span></span><br><span class="line">	Name() <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 返回类型所在的路径，如：encoding/base64</span></span><br><span class="line">	PkgPath() <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 返回类型的大小，和 unsafe.Sizeof 功能类似</span></span><br><span class="line">	Size() <span class="keyword">uintptr</span></span><br><span class="line">	<span class="comment">// 返回类型的大小，和 unsafe.Sizeof 功能类似</span></span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 返回类型的类型值</span></span><br><span class="line">	Kind() Kind</span><br><span class="line">	<span class="comment">// 类型是否实现了接口 u</span></span><br><span class="line">	Implements(u Type) <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 是否可以赋值给 u</span></span><br><span class="line">	AssignableTo(u Type) <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 是否可以类型转换成 u</span></span><br><span class="line">	ConvertibleTo(u Type) <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 类型是否可以比较</span></span><br><span class="line">	Comparable() <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 类型所占据的位数</span></span><br><span class="line">	Bits() <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 返回通道的方向，只能是 chan 类型调用</span></span><br><span class="line">	ChanDir() ChanDir</span><br><span class="line">	<span class="comment">// 返回类型是否是可变参数，只能是 func 类型调用 </span></span><br><span class="line">	<span class="comment">// 比如 t 是类型 func(x int, y ... float64)</span></span><br><span class="line">	<span class="comment">// 那么 t.IsVariadic() == true</span></span><br><span class="line">	IsVariadic() <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 返回内部子元素类型，只能由类型 Array, Chan, Map, Ptr, or Slice 调用</span></span><br><span class="line">	Elem() Type</span><br><span class="line">    <span class="comment">// 返回结构体类型的第 i 个字段，只能是结构体类型调用</span></span><br><span class="line">    <span class="comment">// 如果 i 超过了总字段数，就会 panic</span></span><br><span class="line">	Field(i <span class="keyword">int</span>) StructField</span><br><span class="line">	<span class="comment">// 返回嵌套的结构体的字段</span></span><br><span class="line">	FieldByIndex(index []<span class="keyword">int</span>) StructField</span><br><span class="line">	<span class="comment">// 通过字段名称获取字段</span></span><br><span class="line">	FieldByName(name <span class="keyword">string</span>) (StructField, <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// 返回名称符合 func 函数的字段</span></span><br><span class="line">	FieldByNameFunc(match <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">bool</span>) <span class="params">(StructField, <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function">	// 获取函数类型的第 <span class="title">i</span> 个参数的类型</span></span><br><span class="line"><span class="function">	<span class="title">In</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function">	// 返回 <span class="title">map</span> 的 <span class="title">key</span> 类型，只能由类型 <span class="title">map</span> 调用</span></span><br><span class="line"><span class="function">	<span class="title">Key</span><span class="params">()</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function">	// 返回 <span class="title">Array</span> 的长度，只能由类型 <span class="title">Array</span> 调用</span></span><br><span class="line"><span class="function">	<span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    // 返回类型字段的数量，只能由类型 <span class="title">Struct</span> 调用</span></span><br><span class="line"><span class="function">	<span class="title">NumField</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">	// 返回函数类型的输入参数个数</span></span><br><span class="line"><span class="function">	<span class="title">NumIn</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">	// 返回函数类型的返回值个数</span></span><br><span class="line"><span class="function">	<span class="title">NumOut</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">	// 返回函数类型的第 <span class="title">i</span> 个值的类型</span></span><br><span class="line"><span class="function">	<span class="title">Out</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function">	// 返回类型结构体的相同部分</span></span><br><span class="line"><span class="function">	<span class="title">common</span><span class="params">()</span> *<span class="title">rtype</span></span></span><br><span class="line"><span class="function">    // 返回类型结构体的不同部分</span></span><br><span class="line"><span class="function">	<span class="title">uncommon</span><span class="params">()</span> *<span class="title">uncommonType</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FooIF <span class="keyword">interface</span> &#123;</span><br><span class="line">	DoSomething()</span><br><span class="line">	DoSomethingWithArg(a <span class="keyword">string</span>)</span><br><span class="line">	DoSomethingWithUnCertenArg(a ... <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="keyword">int</span></span><br><span class="line">	B <span class="keyword">string</span></span><br><span class="line">	C <span class="keyword">struct</span> &#123;</span><br><span class="line">		C1 <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span> <span class="title">DoSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(f.A, f.B)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span> <span class="title">DoSomethingWithArg</span><span class="params">(a <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(f.A, f.B, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span> <span class="title">DoSomethingWithUnCertenArg</span><span class="params">(a ... <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(f.A, f.B, a[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span> <span class="title">returnOneResult</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> simpleObj Foo</span><br><span class="line">	<span class="keyword">var</span> pointer2obj = &amp;simpleObj</span><br><span class="line">	<span class="keyword">var</span> simpleIntArray = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> simpleMap = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"a"</span>: <span class="string">"b"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> simpleChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">uint64</span></span><br><span class="line">	<span class="keyword">var</span> y <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	varType := reflect.TypeOf(simpleObj)</span><br><span class="line">	varPointerType := reflect.TypeOf(pointer2obj)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对齐之后要多少容量</span></span><br><span class="line">	fmt.Println(<span class="string">"Align: "</span>, varType.Align())</span><br><span class="line">	<span class="comment">// 作为结构体的`field`要对其之后要多少容量</span></span><br><span class="line">	fmt.Println(<span class="string">"FieldAlign: "</span>, varType.FieldAlign())</span><br><span class="line">	<span class="comment">// 类型名称</span></span><br><span class="line">	fmt.Println(<span class="string">"Name: "</span>, varType.Name())</span><br><span class="line">	<span class="comment">// 绝对引入路径</span></span><br><span class="line">	fmt.Println(<span class="string">"PkgPath: "</span>, varType.PkgPath())</span><br><span class="line">	<span class="comment">// 实际上用了多少内存</span></span><br><span class="line">	fmt.Println(<span class="string">"Size: "</span>, varType.Size())</span><br><span class="line">	<span class="comment">// 类型的类型值</span></span><br><span class="line">	fmt.Println(<span class="string">"Kind: "</span>, varType.Kind())</span><br><span class="line">	<span class="comment">// 有多少函数(指针对象能获取全部函数,非指针的只能获取非指针函数)</span></span><br><span class="line">	fmt.Println(<span class="string">"NumMethod: "</span>, varPointerType.NumMethod())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过名字获取一个函数</span></span><br><span class="line">	m, success := varPointerType.MethodByName(<span class="string">"DoSomethingWithArg"</span>)</span><br><span class="line">	<span class="keyword">if</span> success &#123; <span class="comment">// 调用该方法</span></span><br><span class="line">		m.Func.Call([]reflect.Value&#123;</span><br><span class="line">			reflect.ValueOf(pointer2obj),</span><br><span class="line">			reflect.ValueOf(<span class="string">"sad"</span>),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过索引获取函数</span></span><br><span class="line">	m = varPointerType.Method(<span class="number">1</span>)</span><br><span class="line">	m.Func.Call([]reflect.Value&#123; <span class="comment">// 调用该方法</span></span><br><span class="line">		reflect.ValueOf(pointer2obj),</span><br><span class="line">		reflect.ValueOf(<span class="string">"sad2"</span>),</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否实现了某个接口</span></span><br><span class="line">	fmt.Println(<span class="string">"Implements:"</span>, varPointerType.Implements(reflect.TypeOf((*FooIF)(<span class="literal">nil</span>)).Elem()))</span><br><span class="line">	<span class="comment">//  看看指针多少bit</span></span><br><span class="line">	fmt.Println(<span class="string">"Bits: "</span>, reflect.TypeOf(x).Bits())</span><br><span class="line">	<span class="comment">// 查看array, chan, map, ptr, slice的元素类型</span></span><br><span class="line">	fmt.Println(<span class="string">"Elem: "</span>, reflect.TypeOf(simpleIntArray).Elem().Kind())</span><br><span class="line">	<span class="comment">// 查看Array长度</span></span><br><span class="line">	fmt.Println(<span class="string">"Len: "</span>, reflect.TypeOf(simpleIntArray).Len())</span><br><span class="line">	<span class="comment">// 查看结构体类型的第 i 个字段</span></span><br><span class="line">	fmt.Printf(<span class="string">"Field: %+v \n"</span>, varType.Field(<span class="number">1</span>))</span><br><span class="line">	<span class="comment">// 查看嵌套的结构体的字段</span></span><br><span class="line">	fmt.Printf(<span class="string">"FieldByIndex %+v \n"</span>, varType.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">0</span>&#125;))</span><br><span class="line">	<span class="comment">// 通过字段名称获取字段</span></span><br><span class="line">	fi, success2 := varType.FieldByName(<span class="string">"A"</span>)</span><br><span class="line">	<span class="keyword">if</span> success2 &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"FieldByName: %+v \n"</span>, fi)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查看名称符合 func 函数的字段</span></span><br><span class="line">	fi, success2 = varType.FieldByNameFunc(<span class="function"><span class="keyword">func</span><span class="params">(fieldName <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fieldName == <span class="string">"A"</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> success2 &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"FieldByName: %+v \n"</span>, fi)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  查看结构体数量</span></span><br><span class="line">	fmt.Println(<span class="string">"NumField"</span>, varType.NumField())</span><br><span class="line">	<span class="comment">// 查看map的key类型</span></span><br><span class="line">	fmt.Println(<span class="string">"Key: "</span>, reflect.TypeOf(simpleMap).Key().Name())</span><br><span class="line">	<span class="comment">// 查看函数有多少个参数</span></span><br><span class="line">	fmt.Println(<span class="string">"NumIn: "</span>, reflect.TypeOf(pointer2obj.DoSomethingWithUnCertenArg).NumIn())</span><br><span class="line">	<span class="comment">// 查看函数参数的类型</span></span><br><span class="line">	fmt.Println(<span class="string">"In: "</span>, reflect.TypeOf(pointer2obj.DoSomethingWithUnCertenArg).In(<span class="number">0</span>))</span><br><span class="line">	<span class="comment">// 查看最后一个参数，是否解构了</span></span><br><span class="line">	fmt.Println(<span class="string">"IsVariadic: "</span>, reflect.TypeOf(pointer2obj.DoSomethingWithUnCertenArg).IsVariadic())</span><br><span class="line">	<span class="comment">// 查看函数有多少输出</span></span><br><span class="line">	fmt.Println(<span class="string">"NumOut: "</span>, reflect.TypeOf(pointer2obj.DoSomethingWithUnCertenArg).NumOut())</span><br><span class="line">	<span class="comment">// 查看函数输出的类型</span></span><br><span class="line">	fmt.Println(<span class="string">"Out: "</span>, reflect.TypeOf(pointer2obj.returnOneResult).Out(<span class="number">0</span>))</span><br><span class="line">	<span class="comment">// 查看通道的方向, 3双向。</span></span><br><span class="line">	fmt.Println(<span class="string">"ChanDir: "</span>, <span class="keyword">int</span>(reflect.TypeOf(simpleChan).ChanDir()))</span><br><span class="line">	<span class="comment">// 查看该类型是否可以比较。不能比较的slice, map, func</span></span><br><span class="line">	fmt.Println(<span class="string">"Comparable: "</span>, varPointerType.Comparable())</span><br><span class="line">	<span class="comment">// 查看类型是否可以转化成另外一种类型</span></span><br><span class="line">	fmt.Println(<span class="string">"ConvertibleTo: "</span>, varPointerType.ConvertibleTo(reflect.TypeOf(<span class="string">"a"</span>)))</span><br><span class="line">	<span class="comment">// 该类型的值是否可以另外一个类型</span></span><br><span class="line">	fmt.Println(<span class="string">"AssignableTo: "</span>, reflect.TypeOf(x).AssignableTo(reflect.TypeOf(y)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="value"><a href="#value" class="headerlink" title="value"></a>value</h1><p>Value 字段还有很多方法,可以去看文档: <a href="http://docscn.studygolang.com/pkg/reflect/" target="_blank" rel="noopener">http://docscn.studygolang.com/pkg/reflect/</a>,或者去<code>src/reflect/value.go</code>看看源码，搜索 <code>func(v Value)</code> 就能看到。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">value.CanSet()返回值能否更改</span><br><span class="line">value.MethodByName(<span class="string">"name"</span>)<span class="comment">//根据方法名查找方法返回Value</span></span><br><span class="line">value.FieldByName(<span class="string">"name"</span>)<span class="comment">//根据属性名查找属性返回Value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">CanAddr</span><span class="params">()</span> <span class="title">Value</span>///这个方法是设置值的方法的基础，使用<span class="title">ValueOf</span><span class="params">()</span>生成一个<span class="title">Value</span>时，参数是值传递的，因此设置这个参数一点意义也没有。正确的方法是传入一个指针，然后调用<span class="title">Elem</span><span class="params">()</span>方法来生成其指向的元素对应的<span class="title">Value</span>对象</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Addr</span><span class="params">()</span> <span class="title">Value</span>//获得其地址  如果<span class="title">CanAddr</span><span class="params">()</span>返回<span class="title">false</span>，那么这个调用会<span class="title">panic</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">UnsafeAddr</span><span class="params">()</span> <span class="title">uintptr</span>//和<span class="title">Addr</span><span class="params">()</span>方法有同样的要求</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">CanSet</span><span class="params">()</span> <span class="title">bool</span>//是否可以修改其值，一个值必须是可以获得地址且不能通过访问结构的非导出字段获得，方可被修改</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Set</span><span class="params">(x Value)</span> //设置值   如果<span class="title">CanSet</span><span class="params">()</span>返回<span class="title">false</span>，那么<span class="title">panic</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Convert</span><span class="params">(t Type)</span> <span class="title">Value</span>//转换为其他类型的值 如果无法使用标准<span class="title">Go</span>转换规则来转换，那么<span class="title">panic</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Iterface</span></span>&#123;&#125; <span class="keyword">interface</span>&#123;&#125;<span class="comment">//以空接口类型获得值  如果Value是通过访问结构的非导出字段获得，panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">IsValid</span><span class="params">()</span> <span class="title">bool</span> // 是否是一个合法的<span class="title">Value</span>对象   只有零值才会返回<span class="title">false</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Kind</span><span class="params">()</span> <span class="title">Kind</span>      //* 所属的类型分类   零值会返回<span class="title">Invalid</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span>//* 字符串格式   返回值的格式为&lt;类型 值&gt;</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Type</span><span class="params">()</span> <span class="title">Type</span>//类型</span></span><br><span class="line"><span class="function">* 方法集和方法</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">NumMethod</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Method</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">MethodByName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function">//<span class="title">Type</span>类型定义了同名方法，但是返回的是类型信息，这里返回的是值信息。<span class="title">Method</span><span class="params">()</span>方法，如果<span class="title">v</span>没有任何方法集，或者<span class="title">index</span>越界，那么<span class="title">panic</span>。<span class="title">MethodByName</span><span class="params">()</span>方法，如果没有找到名为<span class="title">name</span>的方法，那么返回一个零值</span></span><br><span class="line"><span class="function">*属性</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">NumField</span><span class="params">()</span> <span class="title">int</span>   //结构字段数量</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Field</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Value</span>       //使用索引来访问字段，索引从0开始，如果越界将<span class="title">panic</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">FieldByName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Value</span>       //使用名称来访问字段，如果未找到那么返回<span class="title">false</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span><span class="title">FieldByNameFunc</span><span class="params">(match <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">bool</span>) <span class="title">Value</span>        //访问名称使得<span class="title">match</span>函数返回<span class="title">true</span>的字段，在同一个内嵌层次上，只能有一个字段使得<span class="title">match</span>返回<span class="title">true</span>。如果同一层次上多个字段使得<span class="title">match</span>返回<span class="title">true</span>，</span></span><br><span class="line"><span class="function">那么这些字段都认为是不符合要求的</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FieldByIndex</span><span class="params">(index []<span class="keyword">int</span>)</span> <span class="title">Value</span>        //这个方法使得访问结构的内嵌字段成为可能。将访问各个层次的字段的索引排列起来，就形成了一个[]<span class="title">int</span>，参数<span class="title">index</span>不可越界，否则<span class="title">panic</span> </span></span><br><span class="line"><span class="function">*函数类型值</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Call</span><span class="params">(in []Value)</span>[]<span class="title">Value</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">CallSlice</span><span class="params">(in []Value)</span> []<span class="title">Value</span></span></span><br><span class="line"><span class="function">注：<span class="title">Call</span><span class="params">()</span>方法用来调用函数<span class="params">(参数可变或者固定)</span>，采用的是用户代码使用的调用格式。<span class="title">CallSlice</span><span class="params">()</span>方法专门用于调用参数可变的函数，它采用了编译器使用的调用格式。这两种调用格式的区别在于:</span></span><br><span class="line"><span class="function"><span class="title">u</span> 对于参数固定的函数，两种格式没有任何区别，都是按照位置，将实参赋予形参</span></span><br><span class="line"><span class="function"><span class="title">u</span> 对于参数可变的函数，编译器格式会特别处理最后一个参数，将剩余的实参依次放入一个<span class="title">slice</span>内，传递给可变形参的就是这个<span class="title">slice</span>。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Pointer</span><span class="params">()</span> <span class="title">uintptr</span>        //以<span class="title">uintptr</span>返回函数的值，这个值并不能独一无二的识别一个函数，只是保证如果函数为<span class="title">nil</span>，那么这个值为0</span></span><br><span class="line"><span class="function">*类型信息</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ChanDir</span><span class="params">()</span> <span class="title">ChanDir</span>//判断通道的方向</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Type</span>//元素的类型</span></span><br><span class="line"><span class="function">*通道值</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">IsNil</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Pointer</span><span class="params">()</span> <span class="title">uintptr</span>    //以<span class="title">unitptr</span>返回其值，没有使用<span class="title">unsafe</span>.<span class="title">Pointer</span>类型，所以不需要导入<span class="title">unsafe</span>包</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span>        //通道当前元素数量</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span>        //通道的长度</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Send</span><span class="params">(x Value)</span>         //发送一个值，<span class="title">x</span>必表示一个可以赋值给通道元素类型的值</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">TrySend</span><span class="params">(x Value)</span> <span class="title">bool</span>        //尝试以非阻塞的方式发送一个值，返回操作成功与否</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Recv</span><span class="params">()</span> <span class="params">(Value,<span class="keyword">bool</span>)</span>      //接收一个值，如果通道已经关闭，返回一个<span class="title">Value</span>零值。由于通道本身可能传输<span class="title">Value</span>零值，所以必须额外使用一个布尔返回值来表示接收是否成功</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">TryRecv</span><span class="params">()</span> <span class="params">(Value,<span class="keyword">bool</span>)</span>       //尝试以非阻塞的方式接收一个值</span></span><br><span class="line"><span class="function">*<span class="title">slice</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Type</span>            //类型</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">IsNil</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Pointer</span><span class="params">()</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Index</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Value</span>   //访问某个元素</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Slice</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">Value</span> //访问某个子<span class="title">slice</span>,下标必须合法</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Slice3</span><span class="params">(i,j,k)</span> <span class="title">Value</span>  //以<span class="title">Go1</span>.3引入的3下标格式访问某个子<span class="title">slice</span>，下标必须合法</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetCap</span><span class="params">(i <span class="keyword">int</span>)</span>        //要求<span class="title">i</span>必须在[<span class="title">v</span>.<span class="title">Len</span><span class="params">()</span>,<span class="title">v</span>.<span class="title">Cap</span><span class="params">()</span>]之间</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetLen</span><span class="params">(i <span class="keyword">int</span>)</span>        //<span class="title">i</span>必须在[0,<span class="title">v</span>.<span class="title">Cap</span><span class="params">()</span>]之间</span></span><br><span class="line"><span class="function">*映射类型</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">IsNil</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">MapKeys</span><span class="params">()</span> []<span class="title">Value</span>//返回所有的键值</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">MapIndex</span><span class="params">(key Value)</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetMapIndex</span><span class="params">(key, x Value)</span>//如果<span class="title">x</span>是零值，那么表示删除一个元素</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Pointer</span><span class="params">()</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function">*指针类型   <span class="title">Go</span>语言提供了两种指针类型，一种是通过*和其他类型复合而成，另一种是<span class="title">unsafe</span>.<span class="title">Pointer</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Type</span>    值</span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(v Value)</span> <span class="title">IsNil</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(v Value)</span> <span class="title">Pointer</span><span class="params">()</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function">*数组</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(v Value)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(v Value)</span> <span class="title">Slice</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(v Value)</span> <span class="title">Slice3</span><span class="params">(i, j, k <span class="keyword">int</span>)</span> <span class="title">Value</span>//这两个方法要求<span class="title">v</span>.<span class="title">CanAddr</span><span class="params">()</span>返回<span class="title">true</span></span></span><br><span class="line"><span class="function">*接口类型</span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(v Value)</span> <span class="title">IsNil</span><span class="params">()</span> <span class="title">bool</span>//判断接口是否为空</span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span>//返回接口包含的真实值</span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(v Value)</span> <span class="title">InterfaceData</span><span class="params">()</span> [2]<span class="title">uintptr</span>//这个方法的用法比较奇怪，还未能找到一个合适的例子</span></span><br><span class="line"><span class="function">[]<span class="title">byte</span>类型</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span><span class="title">Bytes</span><span class="params">()</span> []<span class="title">bytes</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span><span class="title">SetBytes</span><span class="params">(x []bytes)</span></span></span><br><span class="line"><span class="function">字符串类型</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetString</span><span class="params">(x <span class="keyword">string</span>)</span>//设置字符串的值</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Index</span><span class="params">(i <span class="keyword">int</span>)</span><span class="title">Value</span>//访问单个字节</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span>//字符串的长度</span></span><br></pre></td></tr></table></figure>

<h1 id="StructField"><a href="#StructField" class="headerlink" title="StructField"></a>StructField</h1><p>结构的字段具有很多特殊信息，定义了<code>StructField</code>类型来表示一个字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumField</span><span class="params">()</span> <span class="title">int</span>     //结构字段数量</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Field</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">StructField</span>       //使用索引来访问字段，索引从0开始，如果越界将<span class="title">panic</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FieldByName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(StructField,<span class="keyword">bool</span>)</span>        //使用名称来访问字段，如果未找到那么返回<span class="title">false</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FieldByNameFunc</span><span class="params">(match <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">bool</span>) <span class="params">(StructField,<span class="keyword">bool</span>)</span>        //访问名称使得<span class="title">match</span>函数返回<span class="title">true</span>的字段，在同一个内嵌层次上，只能有一个字段使得<span class="title">match</span>返回<span class="title">true</span>。如果同一层次上多个字段使得<span class="title">match</span>返回<span class="title">true</span>，</span></span><br><span class="line"><span class="function">那么这些字段都认为是不符合要求的</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FieldByIndex</span><span class="params">(index []<span class="keyword">int</span>)</span> <span class="title">StructField</span>      //这个方法使得访问结构的内嵌字段成为可能。将访问各个层次的字段的索引排列起来，就形成了一个[]<span class="title">int</span>，参数<span class="title">index</span>不可越界，否则<span class="title">panic</span>             </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">StructField</span> <span class="title">struct</span></span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span>      <span class="comment">//名称</span></span><br><span class="line">    PkgPath <span class="keyword">string</span>      <span class="comment">//* 对于导出字段，为空字符串* 对于非导出字段，是定义该字段类型的包名</span></span><br><span class="line">    Type        Type</span><br><span class="line">    Tag         StructTag</span><br><span class="line">    Offset <span class="keyword">uintptr</span>     <span class="comment">//在结构内的位移</span></span><br><span class="line">    Index []<span class="keyword">int</span>       <span class="comment">//当使用Type.FieldByIndex()方法的参数</span></span><br><span class="line">    Anonymous  <span class="keyword">bool</span>        <span class="comment">//是否为匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>StructTag</code>描述了结构字段的<code>tag</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tag格式为:</span><br><span class="line">  * 由多个部分连接而成，部分之间有可选的空格</span><br><span class="line">  * 部分格式为 key:value</span><br><span class="line">  * key是非空的字符串，由非控制字符组成，并且不可以是空格、双引号、冒号</span><br><span class="line">  * 值由双引号包围，遵循Go字符串字面值语法</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tag StructTag)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span>     //将一个<span class="title">tag</span>看做映射，各个部分就是映射的元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Kind</code></p>
<p>reflect包使用Kind类型来表示类型所属的分类</p>
</li>
</ul>
<h1 id="反射的三大定律"><a href="#反射的三大定律" class="headerlink" title="反射的三大定律"></a>反射的三大定律</h1><blockquote>
<ol>
<li><p>Reflection goes from interface value to reflection object.</p>
</li>
<li><p>Reflection goes from reflection object to interface value.</p>
</li>
<li><p>To modify a reflection object, the value must be settable.</p>
</li>
</ol>
</blockquote>
<ul>
<li><ol>
<li>反射可以从接口类型到反射类型对象<ul>
<li>反射是一种检测存储在 interface 中的类型和值机制。这可以通过 TypeOf 函数和 ValueOf 函数得到。</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>反射可以从反射类型对象到接口类<ul>
<li>将 ValueOf 的返回值通过 Interface()函数反向转变成 interface 变量</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>修改反射类型变量的内部值需要保证其可设置性<ul>
<li>如果想要操作原变量，反射变量 Value 必须要使用原变量的地址才行。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>Reflection goes from reflection object to interface value.</p>
<p>To modify a reflection object, the value must be settable.</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Chc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.caihc.site/posts/2f2b16bc/">https://blog.caihc.site/posts/2f2b16bc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.caihc.site">Chc</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/源码/">源码    </a></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/posts/b60c2e78/"><img class="prev_cover lozad" data-src="http://qiniu.caihc.site/mysql/mysql%E8%BF%90%E7%BB%B4.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Mysql基本运维知识总结</span></div></a></div><div class="next-post pull-right"><a href="/posts/39601882/"><img class="next_cover lozad" data-src="http://qiniu.caihc.site/mongo/mongo_conf.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>MongoDB4.0配置说明</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headling"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span>&nbsp;相關文章</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/95e450d8/"><img class="relatedPosts_cover lozad" data-src="http://qiniu.caihc.site/go/context/golang_context.jpg"><div class="relatedPosts_title">golang底层解析之Context</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Chc</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode"> </i><i class="fa fa-plus" id="font_plus"></i><i class="fa fa-minus" id="font_minus"></i><i class="fa fa-comments-o" id="to_comment"> </i><a class="translate_chn_to_cht" id="translateLink"></a><i class="fa fa-moon-o nightshift" id="nightshift"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/baidupush.js"></script><script async src="/js/search/local-search.js"></script><script src="/js/tw_cn.js"></script><script>$(document).ready(function() { 
  initializeChineseConversion();
});
function simplifyTextInPage(simplified) {
  if (simplified) {
    $(document.body).t2s();
    $('#translateLink').addClass('simplified');
    $('#translateLink').text('繁');
  } else {
    $(document.body).s2t();
    $('#translateLink').removeClass('simplified');
    $('#translateLink').text('簡');
  }
}
function initializeChineseConversion() {
  var simplified = +Cookies.get('simplified');
  // ?lang=zh-Hans, ?lang=zh-Hant
  var scriptCode = /[?&;]lang=[^&;]*(Han[st])/i.exec(window.location.search);
  if (scriptCode) {
    simplified = +(scriptCode[1].match(/Hans/i) != null);
    Cookies.set('simplified', simplified, {expires: 7, path: '/'});
  }
  simplifyTextInPage(simplified);
  $('#translateLink').click(function() {
    simplified = +!simplified;
    Cookies.set('simplified', simplified, {expires: 7, path: '/'});
    simplifyTextInPage(simplified);
    $(this).blur();
  });
}
</script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>