<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>java的23种设计模式 | Chc</title><meta name="description" content="java的23种设计模式"><meta name="keywords" content="基础"><meta name="author" content="Chc"><meta name="copyright" content="Chc"><meta name="format-detection" content="telephone=no"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://blog.caihc.site/posts/5e103278/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="java的23种设计模式"><meta name="twitter:description" content="java的23种设计模式"><meta name="twitter:image" content="http://qiniu.caihc.site/blog/sj.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="java的23种设计模式"><meta property="og:url" content="https://blog.caihc.site/posts/5e103278/"><meta property="og:site_name" content="Chc"><meta property="og:description" content="java的23种设计模式"><meta property="og:image" content="http://qiniu.caihc.site/blog/sj.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="JVM性能监控与调优" href="https://blog.caihc.site/posts/31cced81/"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#设计模式的源码地址"><span class="toc-number">1.</span> <span class="toc-text">设计模式的源码地址</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#工厂方法模式"><span class="toc-number">2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#抽象工厂"><span class="toc-number">3.</span> <span class="toc-text">抽象工厂</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#建造者模式"><span class="toc-number">4.</span> <span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单例模式"><span class="toc-number">5.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原型模式"><span class="toc-number">6.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#外观模式"><span class="toc-number">7.</span> <span class="toc-text">外观模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#装饰者模式"><span class="toc-number">8.</span> <span class="toc-text">装饰者模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#适配器模式"><span class="toc-number">9.</span> <span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#享元模式"><span class="toc-number">10.</span> <span class="toc-text">享元模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#组合模式"><span class="toc-number">11.</span> <span class="toc-text">组合模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#桥接模式"><span class="toc-number">12.</span> <span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#模板方法"><span class="toc-number">13.</span> <span class="toc-text">模板方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#迭代器模式"><span class="toc-number">14.</span> <span class="toc-text">迭代器模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#策略模式"><span class="toc-number">15.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解释器模式"><span class="toc-number">16.</span> <span class="toc-text">解释器模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#观察者模式"><span class="toc-number">17.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#备忘录模式"><span class="toc-number">18.</span> <span class="toc-text">备忘录模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#命令模式"><span class="toc-number">19.</span> <span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#中介者模式"><span class="toc-number">20.</span> <span class="toc-text">中介者模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#责任链模式"><span class="toc-number">21.</span> <span class="toc-text">责任链模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问者模式"><span class="toc-number">22.</span> <span class="toc-text">访问者模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#状态模式"><span class="toc-number">23.</span> <span class="toc-text">状态模式</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://qiniu.caihc.site/blog/sj.jpeg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Chc</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">java的23种设计模式</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-06-13<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-06-14</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a></span></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="设计模式的源码地址"><a href="#设计模式的源码地址" class="headerlink" title="设计模式的源码地址"></a>设计模式的源码地址</h1><p><a href="https://github.com/chcGolang/java_design_coding" target="_blank" rel="noopener">设计模式Github源码</a></p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:定义一个创建对象的接口,但让实现这个接口的类来决定实例化哪个类,工厂方法让类的实例化推迟到子类中进行</li>
<li>类型:创建型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>创建对象需要大量重复的代码</li>
<li>客户端(应用层)不依赖于产品类实例如何被创建,实现等细节</li>
<li>一个类通过其子类来指定创建哪个对象</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>用户只需要关心所需产品对应的工厂,无须关心创建细节</li>
<li>加入新产品符合开闭原则,提高可扩展性</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>类的个数容易过多,增加复杂度</li>
<li>增加了系统的抽象性和理解难度</li>
</ul>
<h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:抽象工厂模式提供创建一系列相关或相互依赖对象的接口</li>
<li>无须指定他们具体的类</li>
<li>类型:创建型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>客户端(应用层)不依赖于产品类实例如何被创建,实现等细节</li>
<li>强调一系列相关的产品对象(属于同一产品族)一起使用创建对象需要大量重复的代码</li>
<li>提供一个产品类的库,所有的产品以同样的接口出现,从而使客户端不依赖于具体实现</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>具体产品在应用辰代码隔离,无须关心创建细节</li>
<li>将一个系列的产品族统一到一起创建</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>规定了所有可能被创建的产品集合,产品族中扩展新的产品困难,需要修改抽象工厂的接口</li>
<li>增加了系统的抽象性和理解难度</li>
</ul>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:将一个复杂对象的构建与它的表示分类,使得同样的构建过程可以创建不同的表示</li>
<li>用户只需指定需要建造的类型就可以得到它们,建造过程及细节不需要知道</li>
<li>类型:创建型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>如果一个对象有非常复杂的内部结构(很多属性)</li>
<li>想把复杂对象的创建和使用分离</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>封装性好,创建和使用分离</li>
<li>扩展性好,建造类之间独立,一定程度上解耦</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>产生多余的Builder对象</li>
<li>产品内部发生变化,建造者都要修改,成本较大</li>
</ul>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:保证一个类仅有一个实例,并提供一个全局访问点</li>
<li>类型:创建型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>想确保任何情况下都绝对只有一个实例</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>在内存里只有一个实例,减少了内存开销</li>
<li>可以避免对资源的多重占用</li>
<li>设置全局访问点,严格控制访问</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>没有接口,扩展困难</li>
</ul>
<p><strong>5. 重点</strong></p>
<ul>
<li>私有构造器</li>
<li>线程安全</li>
<li>延迟加载 </li>
<li>序列化和反序列化安全</li>
<li>反射</li>
</ul>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:指原型实例指定创建对象的种类,并且通过拷贝这些原型创建新对象</li>
<li>不需要知道任何创建的细节,不调用构造函数\</li>
<li>类型:创建型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>类初始化消耗较多资源</li>
<li>new产生的一个对象需要非常繁琐的过程(数据准备,访问权限等)</li>
<li>构造函数比较复杂</li>
<li>循环体中产生大量的对象</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>原型模式性能比直接new一个对象性能高</li>
<li>简化创建过程</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>必须配备克隆方法</li>
<li>对克隆复杂对象或对克隆出的对象进行复杂改造时,容易引入风险</li>
</ul>
<p><strong>5. 扩展</strong></p>
<ul>
<li>深克隆</li>
<li>浅克隆</li>
</ul>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:又叫门面模式,提供一个统一的接口,用来访问子系统中的一群接口</li>
<li>外观模式定义了一个高层接口,让子系统更容易使用</li>
<li>类型:结构型</li>
</ul>
<p><strong>2. 使用场景</strong></p>
<ul>
<li>子系统越来越复杂,增加外观模式提供简单调用接口</li>
<li>构建多层系统结构,利用外观对象作为每层的入口,简化层间调用</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>简化了调用过程,无需了解深入子系统,防止带来风险</li>
<li>减少系统依赖,松散耦合</li>
<li>更好的划分层次</li>
<li>符合迪米特法则,即最少知道原则</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>增加子系统,扩展子系统行为容易引入风险</li>
<li>不符合开闭原则</li>
</ul>
<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:在不改变原有对象的基础之上,将功能附加到对象上</li>
<li>提供了不继承更有弹性的替代方案(扩展原有对象功能)</li>
<li>类型:结构型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>扩展一个类的功能或给一个类添加附加职责</li>
<li>动态的给一个对象添加功能,这些功能可以再动态的撤销</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>继承的有力补充,比继承灵活,不改变原有对象的情况下给一个对象扩展功能</li>
<li>通过使用不同装饰类以及这些装饰类的排列组合,可以实现不同效果</li>
<li>符合开闭原则</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>会出现更多的代码,更多的类,增加程序复杂性</li>
<li>动态装饰时,多层装饰时会更复杂</li>
</ul>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:将一个类的接口转换成客户期望的另一个接口</li>
<li>使原本接口不兼容的类可以一起工作</li>
<li>类型:结构型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>已经存在的类,它的方法和需求不匹配时(方法结构相同或类似)</li>
<li>不是软件设计阶段考虑的设计模式,是随着软件维护,由于不同产品,不同厂家造成功能类似而接口不相同情况下的解决方案</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>能提高类的透明性和复用,现有的类复用但不需要改变</li>
<li>目标类和适配类解耦,提高程序扩展性</li>
<li>符合开闭原则</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>适配器编写过程需要全民考虑,可能会增加系统的复杂性</li>
<li>增加系统代码可读的难度</li>
</ul>
<p><strong>5. 扩展</strong></p>
<ul>
<li>对象适配器</li>
<li>类适配器</li>
</ul>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:提供了减少对象数量从而改善应用所需的对象结构的方式</li>
<li>运用共享技术有效地支持大量细粒度的对象</li>
<li>类型:结构型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>常常用于系统底层的开发,以便解决系统的性能问题</li>
<li>系统有大量相似对象,需要缓冲池的场景</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>减少对象的创建,降低内存中对象的数量,降低系统的内存,提高效率</li>
<li>减少内存之外的其他资源占有</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>关注内/外部状态,关注线程安全问题</li>
<li>是系统,程序的逻辑复杂化</li>
</ul>
<p><strong>5. 扩展</strong></p>
<ul>
<li>内部状态</li>
<li>外部状态 </li>
</ul>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:将对象组合成树型结构以表示”部分-整体”的层次结构</li>
<li>组合模式使客户端对单个对象和组合对象保持一致的方式处理</li>
<li>类型:结构型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>希望客户端可以忽略组合对象和单个对象的差异时</li>
<li>处理一个树形结构时</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>清除地定义层次的复杂对象,表示对象的全部或部分层次</li>
<li>让客户端忽略了层次的差异,方便对整个层次结构进行控制</li>
<li>简化客户端代码</li>
<li>符合开闭原则</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>限制类型时会较为复杂</li>
<li>是设计变得更加抽象</li>
</ul>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:将抽象部分与它的具体实现部分分离,使它们都可以独立地变化</li>
<li>通过组合的方式建立两个类之间联系,而不是继承</li>
<li>类型:结构型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>抽象和具体实现之间增加更多的灵活性</li>
<li>一个类存在两个(或多个)独立变化的维度,且这两个(或多个)</li>
<li>不希望使用继承,或因为多层继承导致系统类的个数剧增</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>分离抽象部分及具体实现部分</li>
<li>提高了系统的可扩展性</li>
<li>符合开闭原则</li>
<li>符合合成复用原则</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>增加了系统的理解与设计难度</li>
<li>需要正确地识别出系统中两个独立变化的维度</li>
</ul>
<h1 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:定义了一个算法的骨架,并允许子类为一个或多个步骤提供实现</li>
<li>模板方法使子类可以在不改变算法结构的情况下,重新定义算法的某些步骤</li>
<li>类型:行为型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>一次性实现一个算法的不变的部分,并将可变的行为留给子类来实现</li>
<li>各子类中公共的行为被提取出来并集中到一个公共父类中,从而避免代码重复</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>提高复用性</li>
<li>提高扩展性</li>
<li>符合开闭原则</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>类数目增加</li>
<li>增加了系统实现的复杂度</li>
<li>继承关系自身缺点,如果父类添加新的抽象方法,所有子类都要改一遍</li>
</ul>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:提供一种方法,顺序访问一个集合对象中的各个元素,而又不暴露该对象的内部表示</li>
<li>类型:行为型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>访问一个集合对象的内容而无暴露它的内部表示</li>
<li>为遍历不同的集合结构提供一个统一的接口</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>分离了集合对象的遍历行为</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>类的个数成对增加</li>
</ul>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:定义了算法家族,分别封装起来,让它们之间可以相互替换,此模式让算法的变化不会影响到使用算法的用户</li>
<li>类型: 行为型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>系统有很多类,而他们的区别仅仅在于他们的行为不同</li>
<li>一个系统需要动态地在几种算法中选择一种</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>开闭原则</li>
<li>避免使用多重条件转移语句</li>
<li>提高算法的保密性和安全性</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>客户端必须知道所有的策略类,并自行决定使用哪个策略类</li>
<li>产生很多策略类</li>
</ul>
<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:给定义一个语言,定义它的文法的一种表示,并定义一个解释器,这解释器使用该表示来解释语言中的句子</li>
<li>为了解释一种语言,而为语言创建的解释器</li>
<li>类型: 行为型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>某个特定类型问题发生频率足够高</li>
</ul>
<p><strong>2. 优点</strong></p>
<ul>
<li>语法由很多类表示,容易改变及扩展此语言</li>
</ul>
<p><strong>3. 缺点</strong></p>
<ul>
<li>当语法规则数目太多时,增加了系统复杂度</li>
</ul>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:定义了对象之间的一对多依赖,让多个观察者对象同时监听某一个主题对象,当主题对象发送变化时,它的所有依赖者(观察者)都会收到通知并更新</li>
<li>类型:行为型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>关联行为场景,建立一套触发机制</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>观察者和被观察者之间建立一个抽象的耦合</li>
<li>观察者模式支持广播通信</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>观察者之间有过多的细节依赖,提高时间消化及程序复杂度</li>
<li>使用要得当,要避免循环调用</li>
</ul>
<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:保存一个对象的某个状态,以便在适当的时候恢复对象</li>
<li>后悔药</li>
<li>类型: 行为型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>保存及恢复数据相关业务场景</li>
<li>后悔的时候,即想恢复到之前的状态</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>为用户提供一种可恢复机制</li>
<li>存档信息的封装</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>资源占有</li>
</ul>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义:将请求封装成对象,以便使用不同的请求</li>
<li>命令模式解决了应用程序中对象的职责以及它们之间的通讯方式</li>
<li>类型:行为型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>请求调用者和请求接收者需要解耦,使得调用者和接收者不直接交互</li>
<li>需要抽象出等待执行的行为</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>降低耦合</li>
<li>容易扩展新命令或者一组命令</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>命令的无限扩展会增加类的数量 提高系统实现复杂度</li>
</ul>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>定义一个封装一组对象如何交互的对象</li>
<li>通过使对象明确地相互引用来促进松散耦合,并允许独立地改变它们的交互</li>
<li>类型:行为型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>系统中对象之间存在复杂的音乐关系,产生的相互依赖关系结构混乱且难以理解</li>
<li>交互的公共行为,如果需要改变行为则可以增加新的中介类</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>将一对多转化成一对一,降低程序复杂度</li>
<li>类之间解耦</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>中介者过多,导致系统复杂</li>
</ul>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>为请求创建一个接收此次请求对象的链</li>
<li>类型:行为型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>一个请求的处理需要多个对象当中的一个或几个协作处理</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>请求的发送者和接收者(请求的处理)解耦</li>
<li>责任链可以动态组合</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>责任链太长或者处理时间过长,影响性能</li>
<li>责任链有可能过多</li>
</ul>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>封装作用于某数据结构(如:list/set/map等)中的各元素的操作</li>
<li>可以在不改变各元素的类的前提下,定义作用于这些元素的操作</li>
<li>类型:行为型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>一个数据结构(如:list/set/map等)包含很多类型对象</li>
<li>数据结构与数据操作分离</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>增加新的操作很容易,即增加一个新的访问者</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>增加新的数据结构困难</li>
<li>具体元素变更比较麻烦</li>
</ul>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p><strong>1. 定义与类型</strong></p>
<ul>
<li>运行一个对象在其内部状态改变时,改变它的行为</li>
<li>类型:行为型</li>
</ul>
<p><strong>2. 适用场景</strong></p>
<ul>
<li>一个对象存在多个状态(不同状态下行为不同),且状态可相互转换</li>
</ul>
<p><strong>3. 优点</strong></p>
<ul>
<li>将不同状态隔离</li>
<li>把各种状态的转换逻辑,分布到State的子类中,减少相互间依赖</li>
<li>增加新的状态非常简单</li>
</ul>
<p><strong>4. 缺点</strong></p>
<ul>
<li>状态多的业务场景导致类数目增加,系统变复杂</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Chc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.caihc.site/posts/5e103278/">https://blog.caihc.site/posts/5e103278/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.caihc.site">Chc</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/基础/">基础    </a></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/posts/31cced81/"><img class="next_cover lozad" data-src="http://qiniu.caihc.site/blog/jvm.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>JVM性能监控与调优</span></div></a></div></nav><div class="relatedPosts"></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Chc</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode"> </i><i class="fa fa-plus" id="font_plus"></i><i class="fa fa-minus" id="font_minus"></i><i class="fa fa-comments-o" id="to_comment"> </i><a class="translate_chn_to_cht" id="translateLink"></a><i class="fa fa-moon-o nightshift" id="nightshift"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/baidupush.js"></script><script async src="/js/search/local-search.js"></script><script src="/js/tw_cn.js"></script><script>$(document).ready(function() { 
  initializeChineseConversion();
});
function simplifyTextInPage(simplified) {
  if (simplified) {
    $(document.body).t2s();
    $('#translateLink').addClass('simplified');
    $('#translateLink').text('繁');
  } else {
    $(document.body).s2t();
    $('#translateLink').removeClass('simplified');
    $('#translateLink').text('簡');
  }
}
function initializeChineseConversion() {
  var simplified = +Cookies.get('simplified');
  // ?lang=zh-Hans, ?lang=zh-Hant
  var scriptCode = /[?&;]lang=[^&;]*(Han[st])/i.exec(window.location.search);
  if (scriptCode) {
    simplified = +(scriptCode[1].match(/Hans/i) != null);
    Cookies.set('simplified', simplified, {expires: 7, path: '/'});
  }
  simplifyTextInPage(simplified);
  $('#translateLink').click(function() {
    simplified = +!simplified;
    Cookies.set('simplified', simplified, {expires: 7, path: '/'});
    simplifyTextInPage(simplified);
    $(this).blur();
  });
}
</script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>