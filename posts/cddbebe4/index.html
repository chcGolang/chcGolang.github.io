<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Go异常处理实践 | Chc</title><meta name="description" content="Go异常处理实践"><meta name="keywords" content><meta name="author" content="Chc"><meta name="copyright" content="Chc"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="http://qiniu.caihc.site/hexo/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://blog.caihc.site/posts/cddbebe4/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Go异常处理实践"><meta name="twitter:description" content="Go异常处理实践"><meta name="twitter:image" content="http://qiniu.caihc.site/20210526105956.png"><meta property="og:type" content="article"><meta property="og:title" content="Go异常处理实践"><meta property="og:url" content="https://blog.caihc.site/posts/cddbebe4/"><meta property="og:site_name" content="Chc"><meta property="og:description" content="Go异常处理实践"><meta property="og:image" content="http://qiniu.caihc.site/20210526105956.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="Nignx知识终结" href="https://blog.caihc.site/posts/e9ce0807/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://blog.caihc.site/","msgToTraditionalChinese":"简","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#panic"><span class="toc-number">1.</span> <span class="toc-text">panic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error"><span class="toc-number">2.</span> <span class="toc-text">error</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#panic-or-error"><span class="toc-number"></span> <span class="toc-text">panic or error?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么标准库中-errors-New-会返回一个指针"><span class="toc-number"></span> <span class="toc-text">为什么标准库中 errors.New 会返回一个指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error-type-错误定义与判断"><span class="toc-number"></span> <span class="toc-text">error type: 错误定义与判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#error-types"><span class="toc-number">1.</span> <span class="toc-text">error types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Opaque-errors"><span class="toc-number">2.</span> <span class="toc-text">Opaque errors</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error-handle-错误处理优化"><span class="toc-number"></span> <span class="toc-text">error handle: 错误处理优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bufio-scan"><span class="toc-number">1.</span> <span class="toc-text">bufio.scan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error-writer"><span class="toc-number">2.</span> <span class="toc-text">error writer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wrap-error-错误包装"><span class="toc-number"></span> <span class="toc-text">wrap error: 错误包装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#errors-wrap-有何作用，为什么不用标准库的-fmt-Errorf-quot-w-quot"><span class="toc-number">1.</span> <span class="toc-text">errors.wrap 有何作用，为什么不用标准库的 fmt.Errorf(&quot;%w&quot;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么不允许处处使用-errors-Wrap"><span class="toc-number">2.</span> <span class="toc-text">为什么不允许处处使用 errors.Wrap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标准库-errors-Is-As-怎么判断错误"><span class="toc-number"></span> <span class="toc-text">标准库 errors.Is / As 怎么判断错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#errors-Is"><span class="toc-number">1.</span> <span class="toc-text">errors.Is</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#errors-As"><span class="toc-number">2.</span> <span class="toc-text">errors.As</span></a></li></ol></li></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://qiniu.caihc.site/20210526105956.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Chc</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="http://qiniu.caihc.site/hexo/hear.jpg" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Go异常处理实践</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-05-26<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-05-26</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/golang/">golang</a></span></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><ol>
<li>在程序启动的时候，如果有强依赖的服务出现故障时 <code>panic</code> 退出</li>
<li>在程序启动的时候，如果发现有配置明显不符合要求， 可以 <code>panic</code> 退出（防御编程）</li>
<li>其他情况下只要不是不可恢复的程序错误，都不应该直接 <code>panic</code> 应该返回 <code>error</code></li>
<li>在程序入口处，例如 <code>gin</code> 中间件需要使用 <code>recover</code> 预防 <code>panic</code> 程序退出</li>
<li>在程序中我们应该避免使用野生的<code>goroutine</code><ol>
<li>如果是在请求中需要执行异步任务，应该使用异步 <code>worker</code> ，消息通知的方式进行处理，避免请求量大时大量 <code>goroutine</code> 创建</li>
<li>如果需要使用 <code>goroutine</code> 时，应该使用同一的 <code>Go</code> 函数进行创建，这个函数中会进行 <code>recover</code> ，避免因为野生 <code>goroutine</code> panic 导致主进程退出</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Go</span><span class="params">(f <span class="keyword">func</span>()</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"panic: %+v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		f()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><ol>
<li><p>我们在应用程序中使用 <code>github.com/pkg/errors</code> 处理应用错误，<strong>注意在公共库当中，我们一般不使用这个</strong></p>
</li>
<li><p><code>error</code>应该是函数的最后一个返回值，当<code>error</code>不为<code>nil</code>时，函数的其他返回值是不可用的状态，不应该对其他返回值做任何期待</p>
<ol>
<li><code>func f() (io.Reader, *S1, error)</code> 在这里，我们不知道 <code>io.Reader</code> 中是否有数据，可能有，也有可能有一部分</li>
</ol>
</li>
<li><p>错误处理的时候应该先判断错误， <code>if err != nil</code> 出现错误及时返回，使代码是一条流畅的直线，避免过多的嵌套.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    a, err := A()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    a, err := A()</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    	<span class="comment">// 其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<strong>应用程序</strong>中出现错误时，使用 <code>errors.New</code> 或者 <code>errors.Errorf</code> 返回错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *usecese)</span> <span class="title">usecase1</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    money := u.repo.getMoney(uid)</span><br><span class="line">    <span class="keyword">if</span> money &lt; <span class="number">10</span> &#123;</span><br><span class="line">        errors.Errorf(<span class="string">"用户余额不足, uid: %d, money: %d"</span>, uid, money)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是调用<strong>应用程序的</strong>其他函数出现错误，请直接返回，如果需要携带信息，请使用 <code>errors.WithMessage</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *usecese)</span> <span class="title">usecase2</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    name, err := u.repo.getUserName(uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"其他附加信息"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是调用其他库（标准库、企业公共库、开源第三方库等）获取到错误时，请使用 <code>errors.Wrap</code> 添加堆栈信息</p>
<ol>
<li>切记，不要每个地方都是用 <code>errors.Wrap</code> 只需要在错误第一次出现时进行 <code>errors.Wrap</code> 即可</li>
<li>根据场景进行判断是否需要将其他库的原始错误吞掉，例如可以把 <code>repository</code> 层的数据库相关错误吞掉，返回业务错误码，避免后续我们分割微服务或者更换 <code>ORM</code> 库时需要去修改上层代码</li>
<li>注意我们在基础库，被大量引入的第三方库编写时一般不使用 <code>errors.Wrap</code> 避免堆栈信息重复</li>
</ol>
</li>
<li><p><strong>禁止</strong>每个出错的地方都打日志，<strong>只需要</strong>在进程的最开始的地方使用 <code>%+v</code> 进行统一打印，例如 <code>http/rpc</code> 服务的中间件</p>
</li>
<li><p>错误判断使用 <code>errors.Is</code> 进行比较</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := A()</span><br><span class="line">    <span class="keyword">if</span> errors.Is(err, io.EOF)&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>错误类型判断，使用 <code>errors.As</code> 进行赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := A()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> errA errorA</span><br><span class="line">    <span class="keyword">if</span> errors.As(err, &amp;errA)&#123;</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>如何判定错误的信息是否足够，想一想当你的代码出现问题需要排查的时候你的错误信息是否可以帮助你快速的定位问题，例如我们在请求中一般会输出参数信息，用于辅助判断错误</p>
</li>
<li><p>对于业务错误，推荐在一个统一的地方创建一个错误字典，错误字典里面应该包含错误的 code，并且在日志中作为独立字段打印，方便做业务告警的判断，错误必须有清晰的错误文档</p>
</li>
<li><p>不需要返回，被忽略的错误<strong>必须</strong>输出日志信息</p>
</li>
<li><p>同一个地方不停的报错，最好不要不停输出错误日志，这样可能会导致被大量的错误日志信息淹没，无法排查问题，比较好的做法是打印一次错误详情，然后打印出错误出现的次数</p>
</li>
<li><p>对同一个类型的错误，采用相同的模式，例如参数错误，不要有的返回 404 有的返回 200</p>
</li>
<li><p>处理错误的时候，需要处理已分配的资源，使用 <code>defer</code> 进行清理，例如文件句柄</p>
</li>
</ol>
<h2 id="panic-or-error"><a href="#panic-or-error" class="headerlink" title="panic or error?"></a>panic or error?</h2><ol>
<li><p>在 Go 中 panic 会导致程序直接退出，是一个致命的错误，如果使用 <code>panic</code> <code>recover</code> 进行处理的话，会存在很多问题</p>
<ol>
<li>性能问题，频繁 panic recover 性能不好</li>
<li>容易导致程序异常退出，只要有一个地方没有处理到就会导致程序进程整个退出</li>
<li>不可控，一旦 panic 就将处理逻辑移交给了外部，我们并不能预设外部包一定会进行处理</li>
</ol>
</li>
<li><p>什么时候使用 panic 呢？</p>
</li>
<li><p>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic</p>
</li>
<li><p>使用 error 处理有哪些好处？</p>
<ol>
<li><p>简单。</p>
</li>
<li><p>考虑失败，而不是成功(Plan for failure, not success)。</p>
</li>
<li><p>没有隐藏的控制流。</p>
</li>
<li><p>完全交给你来控制 error。</p>
</li>
<li><p>Error are values.</p>
</li>
</ol>
</li>
</ol>
<h2 id="为什么标准库中-errors-New-会返回一个指针"><a href="#为什么标准库中-errors-New-会返回一个指针" class="headerlink" title="为什么标准库中 errors.New 会返回一个指针"></a>为什么标准库中 errors.New 会返回一个指针</h2><p>翻看标准库的源代码我们可以发现， <code>errors</code> 库中的 <code>errorString</code> 结构体实现了 <code>error</code> 接口，为什么在 <code>New</code> 一个 error 的时候会返回一个结构体的指针呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="comment">// Each call to New returns a distinct error value even if the text is identical.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">	s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看一个例子，我们同样创建了 <code>errorString</code>的结构体，我们自定义的和标准库中的唯一不同就是，自建的这个返回的是值，而不是指针。<br>在 <code>main</code> 函数的对比中我们就可以发现，我们自定义的 <code>errorString</code> 在对比的时候只要对应的字符串相同就会返回 true，但是标准库的包不会。<br>这是因为，在对比两个 struct 是否相同的时候，会去对比，这两个 struct 里面的各个字段是否是相同的，如果相同就返回 true，但是对比指针的时候会去判断两个指针的地址是否一致。<br><strong>如果字符串相等就返回 true 会导致什么问题呢？</strong><br>如果我有两个包定义了字符串相同的想个错误，在其他库调用对比的时候，可能会由于不同的书写顺序走进不同的分支导致一些不可预期的奇奇怪怪的错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">	text <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.text</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建一个自定义错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errorString&#123;text: s&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errorString1 = New(<span class="string">"test a"</span>)</span><br><span class="line"><span class="keyword">var</span> err1 = errors.New(<span class="string">"test b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> errorString1 == New(<span class="string">"test a"</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err string a"</span>) <span class="comment">// 会输出</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err1 == errors.New(<span class="string">"test b"</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err b"</span>) <span class="comment">// 不会输出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="error-type-错误定义与判断"><a href="#error-type-错误定义与判断" class="headerlink" title="error type: 错误定义与判断"></a>error type: 错误定义与判断</h2><p>哨兵错误，就是定义一些包级别的错误变量，然后在调用的时候外部包可以直接对比变量进行判定，在标准库当中大量的使用了这种方式<br>例如下方 <code>io</code> 库中定义的错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EOF is the error returned by Read when no more input is available.</span></span><br><span class="line"><span class="comment">// Functions should return EOF only to signal a graceful end of input.</span></span><br><span class="line"><span class="comment">// If the EOF occurs unexpectedly in a structured data stream,</span></span><br><span class="line"><span class="comment">// the appropriate error is either ErrUnexpectedEOF or some other error</span></span><br><span class="line"><span class="comment">// giving more detail.</span></span><br><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">"EOF"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrUnexpectedEOF means that EOF was encountered in the</span></span><br><span class="line"><span class="comment">// middle of reading a fixed-size block or data structure.</span></span><br><span class="line"><span class="keyword">var</span> ErrUnexpectedEOF = errors.New(<span class="string">"unexpected EOF"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrNoProgress is returned by some clients of an io.Reader when</span></span><br><span class="line"><span class="comment">// many calls to Read have failed to return any data or error,</span></span><br><span class="line"><span class="comment">// usually the sign of a broken io.Reader implementation.</span></span><br><span class="line"><span class="keyword">var</span> ErrNoProgress = errors.New(<span class="string">"multiple Read calls return no data or error"</span>)</span><br></pre></td></tr></table></figure>

<p>我们在外部判定的时候一般使用等值判定或者使用 <code>errors.Is</code> 进行判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> errors.Is(err, io.EOF)&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种错误处理方式有一个问题是，将 <code>error</code>当做包的 <code>API</code> 暴露给了第三方，这样会导致在做重构或者升级的时候很麻烦，并且这种方式包含的错误信息会十分的有限</p>
<h3 id="error-types"><a href="#error-types" class="headerlink" title="error types"></a>error types</h3><p>这个就类似我们前面定义的 <code>errorString</code> 一样实现了 <code>error</code> 的接口，然后在外部是否类型断言来判断是否是这种错误类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	s <span class="keyword">string</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *MyStruct:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> others:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式相对于哨兵来说，可以包含更加丰富的信息，但是同样也将错误的类型暴露给了外部，例如标准库中的 <code>os.PathError</code></p>
<h3 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h3><p>不透明的错误处理，这种方式最大的特点就是只返回错误，暴露错误判定接口，不返回类型，这样可以减少 API 的暴露，后续的处理会比较灵活，这个一般用在公共库会比较好</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> &#123;</span><br><span class="line">	Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTemporary</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	te, ok := err.(temporary)</span><br><span class="line">	<span class="keyword">return</span> ok &amp;&amp; te.Temporary()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值</p>
<h2 id="error-handle-错误处理优化"><a href="#error-handle-错误处理优化" class="headerlink" title="error handle: 错误处理优化"></a>error handle: 错误处理优化</h2><p>在 go 中常常会存在大量的 <code>if err</code> 代码，下面介绍两种常见的减少这种代码的方式</p>
<h3 id="bufio-scan"><a href="#bufio-scan" class="headerlink" title="bufio.scan"></a>bufio.scan</h3><p>对比下面两个函数的处理我们可以发现， <code>count2</code> 使用 <code>sc.Scan</code> 之后一个 <code>if err</code> 的判断都没有，极大的简化了代码，这是因为在 <code>sc.Scan</code> 做了很多处理，像很多类似的，需要循环读取的都可以考虑像这样包装之后进行处理，这样外部包调用的时候就会非常简洁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计文件行数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(r io.Reader)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		br    = bufio.NewReader(r)</span><br><span class="line">		lines <span class="keyword">int</span></span><br><span class="line">		err   error</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 读取到换行符就说明是一行</span></span><br><span class="line">		_, err = br.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		lines++</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当错误是 EOF 的时候说明文件读取完毕了</span></span><br><span class="line">	<span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> lines, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count2</span><span class="params">(r io.Reader)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		sc    = bufio.NewScanner(r)</span><br><span class="line">		lines <span class="keyword">int</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> sc.Scan() &#123;</span><br><span class="line">		lines++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> lines, sc.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="error-writer"><a href="#error-writer" class="headerlink" title="error writer"></a>error writer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    w   io.Writer</span><br><span class="line">    err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ew *errWriter)</span> <span class="title">write</span><span class="params">(buf []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ew.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, ew.err = ew.w.Write(buf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line">ew := &amp;errWriter&#123;w: fd&#125;</span><br><span class="line">ew.write(p0[a:b])</span><br><span class="line">ew.write(p1[c:d])</span><br><span class="line">ew.write(p2[e:f])</span><br><span class="line"><span class="comment">// and so on</span></span><br><span class="line"><span class="keyword">if</span> ew.err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果去翻 标准库中 bufio.Writer 的源代码，你会发现也有这种用法，这种就是将重复的逻辑进行了封装，然后把 error 暂存，然后我们就只需要在最后判断一下 error 就行了</p>
<h2 id="wrap-error-错误包装"><a href="#wrap-error-错误包装" class="headerlink" title="wrap error: 错误包装"></a>wrap error: 错误包装</h2><h3 id="errors-wrap-有何作用，为什么不用标准库的-fmt-Errorf-quot-w-quot"><a href="#errors-wrap-有何作用，为什么不用标准库的-fmt-Errorf-quot-w-quot" class="headerlink" title="errors.wrap 有何作用，为什么不用标准库的 fmt.Errorf(&quot;%w&quot;)"></a>errors.wrap 有何作用，为什么不用标准库的 <code>fmt.Errorf(&quot;%w&quot;)</code></h3><p>我们先看一下标准库的源码，我们可以发现当 <code>p.wrappedErr != nil</code> 的时候（也就是有 %w）的时候，会使用一个 <code>wrapError</code> 将错误包装，看 <code>wrapError</code> 的源码可以发现，这个方法只是包装了一下原始错误，并且可以做到附加一些文本信息，但是没有堆栈信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	p := newPrinter()</span><br><span class="line">	p.wrapErrs = <span class="literal">true</span></span><br><span class="line">	p.doPrintf(format, a)</span><br><span class="line">	s := <span class="keyword">string</span>(p.buf)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">if</span> p.wrappedErr == <span class="literal">nil</span> &#123;</span><br><span class="line">		err = errors.New(s)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = &amp;wrapError&#123;s, p.wrappedErr&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	p.free()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> wrapError <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg <span class="keyword">string</span></span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *wrapError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *wrapError)</span> <span class="title">Unwrap</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看一下 <code>pkg/errors</code> 的源码，我肯可以发现除了使用 <code>withMessage</code> 附加了错误信息之外还使用 <code>withStack</code> 附加了堆栈信息，这样我们在程序入口处打印日志信息的时候就可以将堆栈信息一并打出了</p>
<h3 id="为什么不允许处处使用-errors-Wrap"><a href="#为什么不允许处处使用-errors-Wrap" class="headerlink" title="为什么不允许处处使用 errors.Wrap"></a>为什么不允许处处使用 errors.Wrap</h3><p>因为每一次 <code>errors.Wrap</code> 的调用都会为错误添加堆栈信息，如果处处调用那会有大量的无用堆栈<br>我们先看一下只有一处 <code>wrap</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"err: %+v"</span>, c())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errors.Wrap(fmt.Errorf(<span class="string">"xxx"</span>), <span class="string">"test"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看结果我们可以发现已经可以打印出全部的堆栈信息了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">err: xxx</span><br><span class="line">test</span><br><span class="line">main.a</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">14</span></span><br><span class="line">main.b</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">18</span></span><br><span class="line">main.c</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">22</span></span><br><span class="line">main.main</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">10</span></span><br><span class="line">runtime.main</span><br><span class="line">	D:/ProgramFiles/<span class="keyword">go</span>/<span class="keyword">go</span><span class="number">.1</span><span class="number">.15</span><span class="number">.12</span>/src/runtime/proc.<span class="keyword">go</span>:<span class="number">204</span></span><br><span class="line">runtime.goexit</span><br><span class="line">	D:/ProgramFiles/<span class="keyword">go</span>/<span class="keyword">go</span><span class="number">.1</span><span class="number">.15</span><span class="number">.12</span>/src/runtime/asm_amd64.s:<span class="number">1374</span></span><br></pre></td></tr></table></figure>

<p>再看多处 <code>wrap</code>的现象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"err: %+v"</span>, c())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errors.Wrap(fmt.Errorf(<span class="string">"xxx"</span>), <span class="string">"a"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errors.Wrap(a(), <span class="string">"b"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errors.Wrap(b(), <span class="string">"c"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到每一处 <code>wrap</code>都添加了一次堆栈信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">err: xxx</span><br><span class="line">a</span><br><span class="line">main.a</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">14</span></span><br><span class="line">main.b</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">18</span></span><br><span class="line">main.c</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">22</span></span><br><span class="line">main.main</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">10</span></span><br><span class="line">runtime.main</span><br><span class="line">	D:/ProgramFiles/<span class="keyword">go</span>/<span class="keyword">go</span><span class="number">.1</span><span class="number">.15</span><span class="number">.12</span>/src/runtime/proc.<span class="keyword">go</span>:<span class="number">204</span></span><br><span class="line">runtime.goexit</span><br><span class="line">	D:/ProgramFiles/<span class="keyword">go</span>/<span class="keyword">go</span><span class="number">.1</span><span class="number">.15</span><span class="number">.12</span>/src/runtime/asm_amd64.s:<span class="number">1374</span></span><br><span class="line">b</span><br><span class="line">main.b</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">18</span></span><br><span class="line">main.c</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">22</span></span><br><span class="line">main.main</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">10</span></span><br><span class="line">runtime.main</span><br><span class="line">	D:/ProgramFiles/<span class="keyword">go</span>/<span class="keyword">go</span><span class="number">.1</span><span class="number">.15</span><span class="number">.12</span>/src/runtime/proc.<span class="keyword">go</span>:<span class="number">204</span></span><br><span class="line">runtime.goexit</span><br><span class="line">	D:/ProgramFiles/<span class="keyword">go</span>/<span class="keyword">go</span><span class="number">.1</span><span class="number">.15</span><span class="number">.12</span>/src/runtime/asm_amd64.s:<span class="number">1374</span></span><br><span class="line">c</span><br><span class="line">main.c</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">22</span></span><br><span class="line">main.main</span><br><span class="line">	E:/work/golang/project/golang-basis/error_basis/pkg_errors/pkg_errors.<span class="keyword">go</span>:<span class="number">10</span></span><br><span class="line">runtime.main</span><br><span class="line">	D:/ProgramFiles/<span class="keyword">go</span>/<span class="keyword">go</span><span class="number">.1</span><span class="number">.15</span><span class="number">.12</span>/src/runtime/proc.<span class="keyword">go</span>:<span class="number">204</span></span><br><span class="line">runtime.goexit</span><br><span class="line">	D:/ProgramFiles/<span class="keyword">go</span>/<span class="keyword">go</span><span class="number">.1</span><span class="number">.15</span><span class="number">.12</span>/src/runtime/asm_amd64.s:<span class="number">1374</span></span><br></pre></td></tr></table></figure>

<h2 id="标准库-errors-Is-As-怎么判断错误"><a href="#标准库-errors-Is-As-怎么判断错误" class="headerlink" title="标准库 errors.Is / As 怎么判断错误"></a>标准库 errors.Is / As 怎么判断错误</h2><h3 id="errors-Is"><a href="#errors-Is" class="headerlink" title="errors.Is"></a>errors.Is</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err == target</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过反射判读 target 是否可以被比较</span></span><br><span class="line">	isComparable := reflectlite.TypeOf(target).Comparable()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 循环判断是否相等</span></span><br><span class="line">		<span class="keyword">if</span> isComparable &amp;&amp; err == target &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 判断是否实现了 is 接口，如果有实现就直接判断</span></span><br><span class="line">		<span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; Is(error) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 去判断是否实现了 unwrap 的接口，如果实现了就进行 unwrap</span></span><br><span class="line">		<span class="keyword">if</span> err = Unwrap(err); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="errors-As"><a href="#errors-As" class="headerlink" title="errors.As"></a>errors.As</h3><p>和 <code>is</code>的逻辑类似，就是不断的进行 <code>unwrap</code>进行比较，只要有一个相同就返回，如果一直到底都不行就返回 false</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"errors: target cannot be nil"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	val := reflectlite.ValueOf(target)</span><br><span class="line">	typ := val.Type()</span><br><span class="line">	<span class="keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"errors: target must be a non-nil pointer"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"errors: *target must be interface or implement error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	targetType := typ.Elem()</span><br><span class="line">	<span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) &#123;</span><br><span class="line">			val.Elem().Set(reflectlite.ValueOf(err))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; As(<span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.As(target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		err = Unwrap(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Chc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.caihc.site/posts/cddbebe4/">https://blog.caihc.site/posts/cddbebe4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.caihc.site">Chc</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/posts/e9ce0807/"><img class="next_cover lozad" data-src="http://qiniu.caihc.site/20201026104446.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Nignx知识终结</span></div></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2021 By Chc</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">简</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/baidupush.js"></script><script async src="/js/search/local-search.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>